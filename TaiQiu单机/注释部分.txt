老的OnTimer中DrawScene()前处理球台滚动状态的数学模型

		float dv, a, b, c, d, A, B, R;
		float max_ex;							// 最大的超出时间，本球对于其他所有的球，加上四壁
		int max_i, max_j, sel_i, sel_j;
		float hit_time[BALLNUM][BALLNUM+10];	// 包括4壁，6洞

		for(int i=0; i<BALLNUM; i++)
		{
			RollBall(i, PP*Balls[i].dir, PP*Balls[i].speed);
		}

	sel_i = -1;			sel_j = -1;
	while(1){
		max_ex = -100.0f;
		for(i=0; i<BALLNUM; i++)
		{
			if(!Balls[i].bUP)			continue;
//			if(Balls[i].speed <= 0.0f)	continue;		别人会撞你
			// 计算和其他球的碰撞
			for(int j=0; j<BALLNUM; j++)
			{
				if(!Balls[j].bUP)			continue;

				if(i >= j)	continue;		// 算上三角阵即可
				if(sel_i < 0 || i==sel_i || i==sel_j || j==sel_i || j==sel_j)	// 需要重算
				{
					a = Balls[i].xpos - Balls[j].xpos;
					b = Balls[i].ypos - Balls[j].ypos;
					c = -BallRadius*(Balls[i].speed*cos(PP*Balls[0].dir) - Balls[j].speed*cos(PP*Balls[j].dir));
					d = -BallRadius*(Balls[i].speed*sin(PP*Balls[0].dir) - Balls[j].speed*sin(PP*Balls[j].dir));
					dv = sqr(a*c+b*d) - (c*c+d*d)*(a*a+b*b-4*BallRadius*BallRadius);
					if(dv < 0.0f)
					{
						dv = -100.0f;		// 只有虚根，给一个负根
					}
					else if(c == 0.0f && d == 0.0f)
					{
						dv = -100.0f;		// 永不相撞，无解，给一个负根
					}
					else
					{
						dv = sqrt(dv);
						dv = (dv-(a*c+b*d))/(c*c+d*d);							// 求大的正根即可
					}
					hit_time[i][j] = dv;
				}
				else															// 无需重算
					dv = hit_time[i][j];

				if(dv > max_ex)
				{
					max_ex = dv;
					max_i = i;
					max_j = j;
				}
			}
			// 计算和4壁的碰撞
			for(j=BALLNUM; j<BALLNUM+4; j++)
			{
				if(sel_i < 0 || i == sel_i || i == sel_j)
				{
					if(j == BALLNUM)
						dv = (Balls[i].xpos-BallRadius+TableLength)/(Balls[i].speed*cos(PP*Balls[i].dir));		// 左壁
					else if(j == BALLNUM + 1)
						dv = (Balls[i].xpos+BallRadius-TableLength)/(Balls[i].speed*cos(PP*Balls[i].dir));		// 右壁
					else if(j == BALLNUM + 2)
						dv = (Balls[i].ypos-BallRadius+TableWidth)/(Balls[i].speed*sin(PP*Balls[i].dir));		// 上壁
					else
						dv = (Balls[i].ypos+BallRadius-TableWidth)/(Balls[i].speed*sin(PP*Balls[i].dir));		// 下壁

					hit_time[i][j] = dv;
				}
				else
					dv = hit_time[i][j];
				if(dv > max_ex)
				{
					max_ex = dv;
					max_i = i;
					max_j = j;
				}
			}
			// 计算和6洞的碰撞
			for(j=BALLNUM+4; j<BALLNUM+10; j++)
			{
				if(sel_i < 0 || i == sel_i || i == sel_j)
				{
					if(j == BALLNUM+4)
					{	A = -TableLength;	B = TableWidth;	R = 2*BallRadius;	} // 左上
					else if(j == BALLNUM+5)
					{	A = -TableLength;	B =-TableWidth;	R = 2*BallRadius;	} // 左下
					else if(j == BALLNUM+6)
					{	A = 0.0f;			B = TableWidth;	R = 1.5f*BallRadius;} // 中上
					else if(j == BALLNUM+7)
					{	A = 0.0f		;	B =-TableWidth;	R = 1.5f*BallRadius;} // 中下
					else if(j == BALLNUM+8)
					{	A = TableLength;	B = TableWidth;	R = 2*BallRadius;	} // 右上
					else
					{	A = TableLength;	B =-TableWidth;	R = 2*BallRadius;	} // 右上

					a = Balls[i].xpos-A;
					b = Balls[i].ypos-B;
					c = -Balls[i].speed*BallRadius*cos(PP*Balls[i].dir);
					d = -Balls[i].speed*BallRadius*sin(PP*Balls[i].dir);
					dv = sqr(a*c+b*d) - (c*c+d*d)*(a*a+b*b-R*R);
					if(dv < 0.0f)
					{
						dv = -100.0f;		// 只有虚根，给一个负根
					}
					else if(c == 0.0f && d == 0.0f)
					{
						dv = -100.0f;		// 永不入袋，无解，给一个负根
					}
					else
					{
						dv = sqrt(dv);
						dv = (dv-(a*c+b*d))/(c*c+d*d);							// 求大的正根即可
					}
					hit_time[i][j] = dv;
				}
				else
					dv = hit_time[i][j];
				if(dv > max_ex)
				{
					max_ex = dv;
					max_i = i;
					max_j = j;
				}
			}
		}

		if(max_ex < 0.0f)	break;		// 已经没有碰撞了，所有球保持角度和速度(减速)

		if(max_j >= BALLNUM+4)			// 最先落袋 :)
		{
			// max_i球的bUp置为FALSE；
			// 把max_j置为-1，因为无需重新计算>BALLNUM的列的数值
			// 重新计算第max_i行的数值（可利用前面的2维循环，所有和max_i有关的行与列）
			// 重新求得max系列数值，回到上面的break；
			Balls[max_i].bUP = FALSE;
			sel_i = max_i;
			sel_j = -1;
		}
		else if(max_j >= BALLNUM)		// 最先碰的是壁 :)
		{
			// 修正max_i球的位置和角度
			// 把max_j置为-1，因为无需重新计算>BALLNUM的列的数值
			// 重新计算第max_i行的数值（可利用前面的2维循环，所有和max_i有关的行与列）
			// 重新求得max系列数值，回到上面的break；
			if(max_j <= BALLNUM+1)						// 左右壁
			{
				Balls[max_i].dir = 180.0f - Balls[max_i].dir;
				Balls[max_i].xpos += Balls[max_i].speed*(1.95)*cos(PP*Balls[max_i].dir)*max_ex;
				Balls[max_i].ypos += Balls[max_i].speed*(-0.05)*sin(PP*Balls[max_i].dir)*max_ex;
			}
			else
			{
				Balls[max_i].dir = - Balls[max_i].dir;
				Balls[max_i].xpos += Balls[max_i].speed*(-0.05)*cos(PP*Balls[max_i].dir)*max_ex;
				Balls[max_i].ypos += Balls[max_i].speed*(1.95)*sin(PP*Balls[max_i].dir)*max_ex;
			}
			Balls[max_i].speed *= 0.95f;

			sel_i = max_i;
			sel_j = -1;
		}
		else
		{
			// 修正max_i球和max_j球的位置和角度
			// 重新计算第max_i和max_j行的数值（可利用前面的2维循环，所有和max_i，max_j有关的行与列）
			// 重新求得max系列数值，回到上面的break；
			R = sqrt(sqr(Balls[max_i].speed) + sqr(Balls[max_j].speed)
					 - 2*Balls[max_i].speed*Balls[max_j].speed*cos(PP*(Balls[max_i].dir-Balls[max_j].dir)));
			R = 0.95f*a;	// value of det v
			A = Balls[max_i].xpos-Balls[max_i].speed*cos(PP*Balls[max_i].dir)*max_ex - 
				Balls[max_j].xpos-Balls[max_j].speed*cos(PP*Balls[max_j].dir)*max_ex;
			B = Balls[max_i].ypos-Balls[max_i].speed*sin(PP*Balls[max_i].dir)*max_ex - 
				Balls[max_j].ypos-Balls[max_j].speed*sin(PP*Balls[max_j].dir)*max_ex;
			A /= 2*BallRadius;		// cos(fai)
			B /= 2*BallRadius;		// sin(fai)
			Balls[max_i].xpos += max_ex*R*A;
			Balls[max_i].ypos += max_ex*R*B;
			Balls[max_j].xpos -= max_ex*R*A;
			Balls[max_j].ypos -= max_ex*R*B;
			a = Balls[max_i].speed*cos(PP*Balls[max_i].dir) + R*A;	// v_i_x
			b = Balls[max_i].speed*sin(PP*Balls[max_i].dir) + R*B;	// v_i_y
			c = Balls[max_j].speed*cos(PP*Balls[max_i].dir) - R*A;	// v_j_x
			d = Balls[max_j].speed*sin(PP*Balls[max_i].dir) - R*B;	// v_j_y
			Balls[max_i].speed = sqrt(a*a+b*b);
			Balls[max_j].speed = sqrt(c*c+d*d);
			Balls[max_i].dir = GetAngle(a, b);
			Balls[max_j].dir = GetAngle(c, d);
		}
	}	
//----------------------------------------------------------------------------------------------------
/*		RollBall(0, PP*Balls[0].dir, PP*Balls[0].speed);
		if(Balls[0].xpos <= BallRadius-TableLength)
		{
			dv = Balls[0].xpos+TableLength-BallRadius;
			dv = -dv/BallRadius/cos(PP*Balls[0].dir);
			RollBall(0, PP*Balls[0].dir, dv);
			Balls[0].dir = 180.0f - Balls[0].dir;
		}
		if(Balls[0].xpos >= TableLength-BallRadius)
		{
			dv = Balls[0].xpos-TableLength+BallRadius;
			dv = -dv/BallRadius/cos(PP*Balls[0].dir);
			RollBall(0, PP*Balls[0].dir, dv);
			Balls[0].dir = 180.0f - Balls[0].dir;
		}
		if(Balls[0].ypos <= BallRadius-TableWidth)
		{
			dv = Balls[0].ypos+TableWidth-BallRadius;
			dv = -dv/BallRadius/sin(PP*Balls[0].dir);
			RollBall(0, PP*Balls[0].dir, dv);
			Balls[0].dir = -Balls[0].dir;
		}
		if(Balls[0].ypos >= TableWidth-BallRadius)
		{
			dv = Balls[0].ypos-TableWidth+BallRadius;
			dv = -dv/BallRadius/sin(PP*Balls[0].dir);
			RollBall(0, PP*Balls[0].dir, dv);
			Balls[0].dir = -Balls[0].dir;
		}
*/

DrawTable原来的代码
/*
	glColor3f(0.0f, 0.5f, 0.0f);
	glBegin(GL_QUADS);								// Draw the Center Table
		glVertex3f(-TableLength, -TableWidth+holeR, 0.0f);
		glVertex3f( TableLength, -TableWidth+holeR, 0.0f);
		glVertex3f( TableLength,  TableWidth-holeR, 0.0f);
		glVertex3f(-TableLength,  TableWidth-holeR, 0.0f);
	glEnd();

	glColor3f(0.1f, 0.3f, 0.1f);
	glBegin(GL_QUADS);
		glVertex3f(-TableLength,		 TableWidth-holeR, BallRadius);
		glVertex3f(-TableLength,		 TableWidth-holeR, 0.0f);
		glVertex3f(-TableLength,		-TableWidth+holeR, 0.0f);
		glVertex3f(-TableLength,		-TableWidth+holeR, BallRadius);
	glEnd();
	glBegin(GL_QUADS);
		glVertex3f(-TableLength,		-TableWidth*0.9f, BallRadius);
		glVertex3f(-TableLength,		 TableWidth*0.9f, BallRadius);
		glVertex3f(-TableLength+holeR,	 TableWidth*0.9f, BallRadius);
		glVertex3f(-TableLength+holeR,	-TableWidth*0.9f, BallRadius);
	glEnd();

	glBegin(GL_QUADS);
		glVertex3f(TableLength,			 TableWidth*0.9f, 0.0f);
		glVertex3f(TableLength,			 TableWidth*0.9f, BallRadius);
		glVertex3f(TableLength,			-TableWidth*0.9f, BallRadius);
		glVertex3f(TableLength,			-TableWidth*0.9f, 0.0f);
	glEnd();
	glBegin(GL_QUADS);
		glVertex3f(TableLength,			 TableWidth*0.9f, BallRadius);
		glVertex3f(TableLength,			-TableWidth*0.9f, BallRadius);
		glVertex3f(TableLength*1.06f,	-TableWidth*0.9f, BallRadius);
		glVertex3f(TableLength*1.06f,	 TableWidth*0.9f, BallRadius);
	glEnd();

	glBegin(GL_QUADS);
		glVertex3f(-TableLength*0.94f,	TableWidth, 0.0f);
		glVertex3f(-TableLength*0.94f,	TableWidth, BallRadius);
		glVertex3f(-TableLength*0.06f,	TableWidth, BallRadius);
		glVertex3f(-TableLength*0.06f,	TableWidth, 0.0f);
	glEnd();
	glBegin(GL_QUADS);
		glVertex3f(-TableLength*0.06f,	TableWidth, BallRadius);
		glVertex3f(-TableLength*0.94f,	TableWidth, BallRadius);
		glVertex3f(-TableLength*0.94f,	TableWidth*1.08f, BallRadius);
		glVertex3f(-TableLength*0.06f,	TableWidth*1.08f, BallRadius);
	glEnd();

	glBegin(GL_QUADS);
		glVertex3f(TableLength*0.06f,	TableWidth, 0.0f);
		glVertex3f(TableLength*0.06f,	TableWidth, BallRadius);
		glVertex3f(TableLength*0.94f,	TableWidth, BallRadius);
		glVertex3f(TableLength*0.94f,	TableWidth, 0.0f);
	glEnd();
	glBegin(GL_QUADS);
		glVertex3f(TableLength*0.94f,	TableWidth, BallRadius);
		glVertex3f(TableLength*0.06f,	TableWidth, BallRadius);
		glVertex3f(TableLength*0.06f,	TableWidth*1.08f, BallRadius);
		glVertex3f(TableLength*0.94f,	TableWidth*1.08f, BallRadius);
	glEnd();

	glBegin(GL_QUADS);
		glVertex3f(-TableLength*0.06f,	-TableWidth, 0.0f);
		glVertex3f(-TableLength*0.06f,	-TableWidth, BallRadius);
		glVertex3f(-TableLength*0.94f,	-TableWidth, BallRadius);
		glVertex3f(-TableLength*0.94f,	-TableWidth, 0.0f);
	glEnd();
	glBegin(GL_QUADS);
		glVertex3f(-TableLength*0.94f,	-TableWidth, BallRadius);
		glVertex3f(-TableLength*0.06f,	-TableWidth, BallRadius);
		glVertex3f(-TableLength*0.06f,	-TableWidth*1.08f, BallRadius);
		glVertex3f(-TableLength*0.94f,	-TableWidth*1.08f, BallRadius);
	glEnd();

	glBegin(GL_QUADS);
		glVertex3f(TableLength*0.94f,	-TableWidth, 0.0f);
		glVertex3f(TableLength*0.94f,	-TableWidth, BallRadius);
		glVertex3f(TableLength*0.06f,	-TableWidth, BallRadius);
		glVertex3f(TableLength*0.06f,	-TableWidth, 0.0f);
	glEnd();
	glBegin(GL_QUADS);
		glVertex3f(TableLength*0.06f,	-TableWidth, BallRadius);
		glVertex3f(TableLength*0.94f,	-TableWidth, BallRadius);
		glVertex3f(TableLength*0.94f,	-TableWidth*1.08f, BallRadius);
		glVertex3f(TableLength*0.06f,	-TableWidth*1.08f, BallRadius);
	glEnd();
*/
原OnTimer中的减速代码		
		for(i=0; i<BALLNUM; i++)
		{
			if(!Balls[0].bUP)	continue;

			dv = Balls[0].speed/50;
			if(dv < MINDV)	dv = MINDV;
			Balls[0].speed -= dv;
			if(Balls[0].speed <= 0.0f)
				Balls[0].speed = 0.0f;
			else
				bAllStop = FALSE;
		}

DoGodJob的老代码（调试用）
//CString ddd;
//long dtime = 0;

void CTaiQiuView::DoGodJob()	// 以小角度（最大240/25度）模拟撞击，可不考虑先后撞击顺序
{
	int i, j;
	float dr, A, B, R, b, c, d;
	float vix, viy, vjx, vjy;
	BOOL bLR, bUD;
//	float si1, si2, di1, di2, sj1, sj2, dj1, dj2;

	for(i=0; i<BALLNUM; i++)
	{
		RollBall(i, PP*Balls[i].dir, PP*Balls[i].speed/25);
	}

	bAllStop = TRUE;

	for(i=0; i<BALLNUM; i++)
	{
		if(!Balls[i].bUP)			continue;

		for(j=0; j<6; j++)				// 入袋
		{
			if(j == 0)
			{	A = -TableLength;	B = TableWidth;	R = CHR*BallRadius;	} // 左上
			else if(j == 1)
			{	A = -TableLength;	B =-TableWidth;	R = CHR*BallRadius;	} // 左下
			else if(j == 2)
			{	A = 0.0f;			B = TableWidth;	R = MHR*BallRadius;} // 中上
			else if(j == 3)
			{	A = 0.0f;			B =-TableWidth;	R = MHR*BallRadius;} // 中下
			else if(j == 4)
			{	A = TableLength;	B = TableWidth;	R = CHR*BallRadius;	} // 右上
			else
			{	A = TableLength;	B =-TableWidth;	R = CHR*BallRadius;	} // 右上

			dr = sqr(Balls[i].xpos-A) + sqr(Balls[i].ypos-B);
			if(dr < sqr(R))				// 进了！！
			{
				Balls[i].bUP = FALSE;
				break;
			}
		}
		if(!Balls[i].bUP)			continue;

		{							// 撞击4壁
			bLR = (Balls[i].xpos < -TableLength+BallRadius) || (Balls[i].xpos > TableLength-BallRadius);
			bUD = (Balls[i].ypos < -TableWidth+BallRadius) || (Balls[i].ypos >  TableWidth-BallRadius);
			if(bLR || bUD)
			{
				if(!FlcStatus[i])		// 之前没有碰壁
				{
					if(bLR)
						Balls[i].dir = 180.0f - Balls[i].dir;
					else
						Balls[i].dir = - Balls[i].dir;

					Balls[i].speed *= 0.95f;
				}
				FlcStatus[i] = 1;		// 碰壁了
			}
			else
			{
				FlcStatus[i] = 0;		// 已经不碰壁了
			}
		}

		for(j=i+1; j<BALLNUM; j++)	// 相互撞击
		{
			if(!Balls[j].bUP)			continue;
//			if(i >= j)	continue;		// 算上三角阵即可

			dr = sqr(Balls[i].xpos-Balls[j].xpos) + sqr(Balls[i].ypos-Balls[j].ypos);
			if(dr <= 4*sqr(BallRadius))
			{
				if(!HitStatus[i][j])	// 之前没有撞上
				{
//					R = sqrt(sqr(Balls[i].speed) + sqr(Balls[j].speed)
//							- 2*Balls[i].speed*Balls[j].speed*cos(PP*(Balls[i].dir-Balls[j].dir)));
//					R *= 0.95f;				// value of det_v

					A = Balls[i].xpos - Balls[j].xpos;
					B = Balls[i].ypos - Balls[j].ypos;
					A /= 2*BallRadius;					// cos(fai)
					B /= 2*BallRadius;					// sin(fai)

					vix = Balls[i].speed*cos(PP*Balls[i].dir);
					viy = Balls[i].speed*sin(PP*Balls[i].dir);
					vjx = Balls[j].speed*cos(PP*Balls[j].dir);
					vjy = Balls[j].speed*sin(PP*Balls[j].dir);

					b = vix*A + viy*B - vjx*A - vjy*B;
					c = 0.025*(sqr(Balls[i].speed)+sqr(Balls[j].speed));
					d = b*b-4*c;
					if(d < 0.0)		R = -b/2;
					else			R = (sqrt(b*b-4*c)-b)/2;

					vix += R*A;
					viy += R*B;
					vjx -= R*A;
					vjy -= R*B;

//					ddd.Format("<%d> ball %d-%d: %f, %f", dtime, i, j, Balls[i].speed, Balls[j].speed);
//					OutputDebugString(ddd);
//					si1 = Balls[i].speed;	sj1 = Balls[j].speed;
//					di1 = Balls[i].dir;		dj1 = Balls[j].dir;

					Balls[i].speed = sqrt(vix*vix+viy*viy);
					Balls[j].speed = sqrt(vjx*vjx+vjy*vjy);
					Balls[i].dir = GetAngle(vix, viy);
					Balls[j].dir = GetAngle(vjx, vjy);

//					ddd.Format(" --- %f, %f\n", Balls[i].speed, Balls[j].speed);
//					OutputDebugString(ddd);
//					si2 = Balls[i].speed;	sj2 = Balls[j].speed;
//					di2 = Balls[i].dir;		dj2 = Balls[j].dir;
//					if(si2>si1 && sj2>sj1)
//					{
//						di2 = di2;
//					}

				}
				HitStatus[i][j] = 1;	// 撞上了！！
			}
			else
			{
				HitStatus[i][j] = 0;	// 解除撞击状态
			}
		}

		dr = Balls[i].speed*0.0005f;
		if(dr < MINDV)	dr = MINDV;
		Balls[i].speed -= dr;

		if(Balls[i].speed <= 0.0f)
			Balls[i].speed = 0.0f;
		else
			bAllStop = FALSE;
	}
//	dtime ++;
}
---------------------------------------------------------------------------------------
			if( Balls[0].xpos < -TableLength/2	&& 
				Balls[0].xpos > -TableLength	&& 
				Balls[0].ypos < TableWidth		&& 
				Balls[0].ypos > -TableWidth)	&&
